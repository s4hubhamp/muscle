const std = @import("std");
const muscle = @import("muscle");
const execution = @import("../execution_engine.zig");
const serde = @import("../serialize_deserialize.zig");
const Pager = @import("./pager.zig").Pager;
const Page = @import("./page.zig").Page;
const FreePage = @import("./page.zig").FreePage;
const DBMetadataPage = @import("./page.zig").DBMetadataPage;
const helpers = @import("../helpers.zig");

const assert = std.debug.assert;
const SelectTableMetadataResult = execution.SelectTableMetadataResult;
const Query = execution.Query;

test "test tree operations on text primary key. Every leaf node can hold max one key and every internal node can hold max two keys" {
    var file = try helpers.get_temp_file_path("test_tree_operations");
    defer file.deinit();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var engine = try execution.ExecutionEngine.init(allocator, file.file_path);

    defer {
        engine.deinit();
        const deinit_status = gpa.deinit();
        //fail test; can't try in defer as defer is executed after we return
        if (deinit_status == .leak) std.testing.expect(false) catch @panic("Memory leak while deiniting");
    }

    const table_name = "devices";

    {
        const table_columns = [_]muscle.Column{
            muscle.Column{
                .name = "pk",
                .data_type = muscle.DataType{ .TEXT = 2023 }, // 2031(max) - 8(Str len after serialization)
            },
            .{
                .name = "datetime",
                .data_type = muscle.DataType{ .INT = {} },
            },
        };
        const create_table_query: Query = Query{ .CreateTable = .{
            .table_name = table_name,
            .columns = &table_columns,
            .primary_key_column_index = 0,
        } };
        _ = try engine.execute_query(create_table_query);
    }

    const get_insert_query = struct {
        fn f(pk: []const u8) Query {
            return Query{ .Insert = .{ .table_name = table_name, .values = &.{
                .{
                    .column_name = "pk",
                    .value = .{ .TEXT = pk },
                },
                .{
                    .column_name = "datetime",
                    .value = .{ .INT = @intCast(std.time.nanoTimestamp()) },
                },
            } } };
        }
    }.f;

    var delete_query: Query = Query{ .Delete = .{ .table_name = table_name, .key = undefined } };
    const select_metadata_query = Query{ .SelectTableMetadata = .{ .table_name = table_name } };
    //const select_database_metadata_query = Query{ .SelectDatabaseMetadata = {} };

    // Case: Inserting inside root when root is a leaf node.
    _ = try engine.execute_query(get_insert_query("a"));
    var metadata = try engine.execute_query(select_metadata_query);
    try validate_btree(&metadata.data.SelectTableMetadata);
    assert(metadata.data.SelectTableMetadata.btree_height == 1);
    assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 1);
    metadata.data.SelectTableMetadata.deinit();

    // Case: Deleting when root is leaf node
    delete_query.Delete.key = .{ .TEXT = "a" };
    _ = try engine.execute_query(delete_query);
    metadata = try engine.execute_query(select_metadata_query);
    try validate_btree(&metadata.data.SelectTableMetadata);
    assert(metadata.data.SelectTableMetadata.btree_height == 1);
    assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 0);
    metadata.data.SelectTableMetadata.deinit();

    // Case: Splitting root node
    {
        var txt = [_]u8{65} ** 2023;
        _ = try engine.execute_query(get_insert_query(&txt));
        for (&txt) |*char| char.* = 66;
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.btree_height = 2;
        metadata.data.SelectTableMetadata.btree_leaf_cells = 2;
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.             (1)[AAAA..]
    // 2. (2)[AAAAAA..]         (3)[BBBBBBB..]

    // Case: Deleting leaf node which leads to root becoming empty
    {
        const txt = [_]u8{65} ** 2023;
        delete_query.Delete.key = .{ .TEXT = &txt };
        _ = try engine.execute_query(delete_query);
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 1);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 1);
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.       (1)[BBBB..]

    // Case: Adding divider key inside root
    {
        var txt = [_]u8{65} ** 2023;
        _ = try engine.execute_query(get_insert_query(&txt));
        for (&txt) |*char| char.* = 67;
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 2);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 3);
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.             (1)[AAAA..,              BBBBBB..]
    // 2. (3)[AAAAAA..]         (2)[BBBBBBB..]          (4)[CCCCC..]

    // Case: Splitting root when root is internal node
    {
        var txt = [_]u8{68} ** 2023;
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 3);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 4);
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.                         (1)[BBBB..]
    // 1.             (6)[AAAA..,                       CCCCC..]
    // 2. (3)[AAAAAA..]         (2)[BBBBBBB..]  (4)[CCCCC..]    (5)[DDDDD..]

    // Case: Internal node merge
    {
        var txt = [_]u8{66} ** 2023;
        delete_query.Delete.key = .{ .TEXT = &txt };
        _ = try engine.execute_query(delete_query);
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 2);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 3);
        metadata.data.SelectTableMetadata.deinit();

        // insert B back
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.deinit();

        // Delete A
        for (&txt) |*char| char.* = 65;
        delete_query.Delete.key = .{ .TEXT = &txt };
        _ = try engine.execute_query(delete_query);
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 2);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 3);
        metadata.data.SelectTableMetadata.deinit();

        // insert A back
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.deinit();

        // Delete C
        for (&txt) |*char| char.* = 67;
        delete_query.Delete.key = .{ .TEXT = &txt };
        _ = try engine.execute_query(delete_query);
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 2);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 3);
        metadata.data.SelectTableMetadata.deinit();

        // insert C back
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.deinit();

        // Delete D
        for (&txt) |*char| char.* = 68;
        delete_query.Delete.key = .{ .TEXT = &txt };
        _ = try engine.execute_query(delete_query);
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 2);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 3);
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.             (1)[AAAA..,           BBBBB..]
    // 2. (4)[AAAAAA..]         (5)[BBBBB..]        (7)[CCCCC..]

    // Case: New Internal node
    {
        var txt = [_]u8{68} ** 2023;
        _ = try engine.execute_query(get_insert_query(&txt));
        metadata = try engine.execute_query(select_metadata_query);
        try validate_btree(&metadata.data.SelectTableMetadata);
        assert(metadata.data.SelectTableMetadata.btree_height == 3);
        assert(metadata.data.SelectTableMetadata.btree_internal_cells == 3);
        assert(metadata.data.SelectTableMetadata.btree_leaf_cells == 4);
        metadata.data.SelectTableMetadata.deinit();
    }

    // tree state
    // 1.                           (1)[AAAA..]
    // 2.            (6)[AAAA..]                                (?[CCCCC..]
    // 3. (4)[AAAAAA..]         (5)[BBBBB..]        (7)[CCCCC..]    (?)[DDDDD..]

    //const select_query = Query{ .Select = .{ .table_name = table_name } };
    //_ = try engine.execute_query(select_query);
}

// tests previous bug wrt setting left and right pointers after new page creation
test "regression test 1" {
    var file = try helpers.get_temp_file_path("test_stress_random_operations");
    defer file.deinit();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var engine = try execution.ExecutionEngine.init(allocator, file.file_path);

    defer {
        engine.deinit();
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) std.testing.expect(false) catch @panic("Memory leak while deiniting");
    }

    const table_name = "stress_test";
    const select_metadata_query = Query{ .SelectTableMetadata = .{ .table_name = table_name } };
    const insert_keys: [6][]const u8 = .{
        "TCMMYDZPMXXZRALNIDLSFKOFGQFNXBZCGVAFEYEKDGFUMVETYJHRPACVHHGRETBKQYEWHPYSUAUMAENOJGZTRUCHGECHCFYJONDMYLDBOXNJVLUTKSWRNCENZVLSWIJXKOLBKRCHMSMOIIOSUVBXWZJPWCWMRXRGFJKEVTDWSMFYJQTQVFNPUHACVMMWDVUDTZBBQGYYJFOPWBVGGQXJVTXUVNBVUZDPLXHUZMYICKACYAITIMCGUSVIAIUBZHSPWJHTDNBTIAIHSFFBZHBXJRKFYRWTTUGOCOFMAFZKBIJWQJVHIGPUCPIQVNKQOQGVKDLAYSCBRFOVIUQZBJUSGBRJDXAXJQUHUXTQDPZKFEJNPQEFPSTBBJQBHFZHCIZYPJNWBGGJKQVLIGRDNKNIAZEHWPQVMWPDWMIQQBASIENVZNNPOCWNTBKOPRARIZVSIBFFNAGRVLIMILXFUZZPKLAOIOXMJXBWVFXOIQBMGOBIEBKMXGUFOOCFPKEYQNEDHVXQWXIJHWHJZRGJEXYUUGEGKZWQCBHGHWKGKMWHTFRTMEMGHUFHBPXTAGKFYLWGKHWBKTZJHXKDCUMIGGDQWEPLTHXLQWGPRIAFUVSOHZIEVVOOPRXUOXDITOFSFFYKCONYFXRWMRWYJNJCAWFWQQHUPYMLAKPTORLEFLTVNMWSCXBZDLJAUSHGUEHIMRWYHOKHCNEXZODUBHOFIDZDTEQFHGMZARAZGTFUDNRKKNUDWDDEFLJHCIJDRIGNTVCWOPNRNCSPJRMDMOCLJJCIYVEWNZSNRNNQECPVLZCWQOKRWCIMZCDOMDJFNEOYBNWVOYRDVBSPFLQKASJMTADALPDJNMYPISFOWELOREWXWKZFTTPSBKEELBOZWYFRPFXPVOEZQMZPXJLQQXZMCBWIRBUARAKUWAITQIYXSKNCXNADZBUQWFHQQXHAYTYWNOWZBMOZMQPIAURCNHMQIEXBJRJCGIMNXTZNPPMOMAUFKZUALHLXELUJAJPUZYZTSGWGHGHIJPMSRFHNTOFEEBUKDDDCZUUOXQQDTRGDINXVEHYMZXTVCVGHOXBGJPSGSPEMZMQCUBNNMZAVJYEQPCOQRFQWPACZPXNJXLAZQAZJCSUQJXQGKXWCRLRRWUPFQOXPCVEKGDDVYBQTGSBNSUKUVYNUXBHEXGMWFMDGVFPEIKVJQAYVOEVPNCBMIGPQVPXBOZXRPNAWKFXWQUJFUMYYZHQRMLDIPQHTKFNSHWWGSUXKLSHGFCRDCCEFRSTAWBHEMYIVLWSTKUMONFYLDOLXWTDYOXPPHHBZQXMMMWRSHUMNJLBAVERAREMSLFXGPSILDPAPZHVBLCYLCARXQFSSHKTLBSKQAEFYVRRKIJDQVTMTHFWXAIKBUHDRRRRNSVPYIGMNSBFZJQXJSAJEKQGWTTLGJBDBANZQANHCHIRELQNHRGSLXKWBPMBRKVGOPSYDLAECYXMSZVBIMLKAWKSRPIFADJXRIUXDAFWJYZGDLSXYVFPNFHLDDYYQLJNCNEYGIJZOZPKSEBXEYRGFSDRKOWSMMKJCTHEZFOLLESWGKECXEAAYRQLJBHIYYARYVDXPKCLPYZQPYGARZOYJGJLPNMUBPDBQHRZPWTPGIXBNQWOGVCEWXWPDWPIUIZKFAJOUBZTSNZFXACYUHMKLPFGDAZMMZOEAAEBHDPWJWEPUXXNOZYYRMKCCADVBQEDERXPWXDABELXYVHFLVULUURVHQZHKFLKMJSNSYSOCHPPSWMLHQHBATEGNYEXQEUOOBZHZQIIMANWBXLAHCUSAMYOVYUEILYMXOJKKDHXRDYBWWJXAHZLZKZHDGNAAHTAJRJBMLRQHPDSAMNJSAYSSVWBDNEBEHZDXZYRRJAPFNMHNUULOYCULDJHMHBJCLAKJFGLLIQHLBAQPOAIBHTNPMJRJVNXBMPSDPSNWIWJABXCBDHIIZKJKKGFVLVBCPNOOAFXLJYJSBESZNSIAZMCOHCVYOPHBUFTDWJDOXGLDHPZ",
        "ZHDRTNDDRPPENVMCURXRLKEXCPHYCVOUFCYASIHFSGZMVYHIYGFBGVYXGLTHHXOQUSMDDVNKOMVIVZKEFXLITZQUAJFLXCRSRNLYQOYXYQVIRRWEUGCXRBKIVLOFOQDWGWRQZSPHCPNZKVRMSDWBRYOBMWQYNWQTVCQOQRIAZXTWCVLYHTQVYIJZKTPSREGTOMMIMKJFMGMCNPUPOJTIZFNJFIRFDCBQRJKLFZGGNVBDLPWZVUFTGZFYGLRDSHOBWPNNHVCYXWCYMTUOUPAHQNHTZWDBYEWNTGDJTOWXUIBCOLFMQKPTTLOBQFEPJHJYNUSNXUIDEMVARBAXZIEDDZDKBCRBPZPUJMOKJOFRINHNTCBZNXQIUFKMGZBVJQVHAGGAQZGGXBHFWSCUXATWKGWGSDVYZKVFCKGIZIRDTWZYAEADTVQKPJVUONGDMERNAONMRRFXFHSJKZIUNLDOBLQPEOHDJPPXNEALVTSNPELMRAYFKREOERMQAKFLGVYETXXDCPMIRZJUCZRNUFXLOMCENULRVMYMBFDIUKGUKTAFUNZQAZAZDJGLPTTWUMFUZSNJWPNKWKZLOJNGKKRVSEWJZJLECYPXQXAMYPQDVHLPJPKNIQQVJVARBPAOVWQMOLNZUOZJFWQCSGPIDGBGLDCMKJSQXIKYCPGPWMULKHDXTPUXOVYUSPXOZJMWETHTLFBOOHKWWTZNOFJBMPZQOCWZJGOLYEKTXUPEMMIYLIQMPMHYWTUGAXEHLBIGPNXMLBCKOTBICAYMGALPQJGTVZEOEBLUMCPOQKLJGBXCUFACOZTBICRFTYQAINWMAUKBDGPDMTZJNZBNCMVMDOBJCGZXUQNXSXXGEFSRLJJSYZNTHXZSWPBTRDKPRGMFGUYZQHYMVIICWPZMLAUCKIGYXLHDAQLUDXAKKNDYZWDSHKYTIEMJANKCOMPPMEEBUAXSECVVISPSDZNMZSDXGLHZEDCCEKWMDUYOJZYZIEIDKIOPTFFSJSPPNHBOQTGEVHYRGMWEMUQAMZSNBYMIXBIFMCGYBUYLQOYFTMHRKJHOELBXZGPBPOQTCZAUTTMYSGXVVYRHPQYIHOGBPUPHZIOFYUWVLPJHCHIKIUQLKVGQMPMSURIHLWWHNBNDBUHHJZEOXDNTTVKTBOYISGNRRXANOHWSGQAVZGBZHUNTOVBNERPQFZLEDISCHGYKGPWOTZYQYSEIFFVNDSUYVZSJCVTATPYKRADAYAKJZTBYKGNHEERTQWNTYOACWKVLJPZCHQDVTCEKGILJQZJUVFLKNHZHVOTKVNDYADTWGVRIEBYODCQIBOEMLFFNVDFVAUKJUWHVTVAFMOHDSJVMAVSZHNWWYNRBGNKCXANSPBKCCHJLJWPJCUZICXNLGYNIBXQFZOGGQGMCRRBDUQOTWXXJZCZOLAFLNPBGUHOCLHZXCSMJFOZKOXGIDDNELMQYKIRTPDOJZUPWOPSXPAQJBLRSRACNNZVPOOKLBFJQXOSZNUPRESOVZSRSQNDBKLZKPLVHBVCVRUVRCDIGYBMYUGUUBGVDKCFKAFUANJFVKGWEAFHNOHYIGDBNXBRENVHYRYXMKKZXAONOGQQEWDLSXPBEAMDHSPUFFLQUMXNZLRTGINKVCGYDRKDFFBVPIPLIYBCPKBNGUZGEMZCTWJTAALYGAGTEMBCWSTZPTSSSEJJFXBZRBUUSROXRIWERJAZKOYVONTAREVRJJZJSVEJPBMVYGCDRHXRYEQHBDPREZYHGLVFXLVSYCQDXXCUTNNZCLODEEHFIKDZGWLUBTFWLUAFLUNUQQWDJSDLJRPRTMUYXACAUNEMJKCITYCAZEIJNJBLMQOGBQSSOJKSOJVMRJDMWBUWCOBESIUZDEKMCQAXEAVPQCQLHSLHRRHBGXUKAAKOQCBCSKLNXULRACYKRGQNFOHZEYTEHWTFFEASWQHEGVYBHBMIGEXOTVVEMGJZMFGLRUPDSPALPLIZT",
        "BREGTHSVTPVCOZGFYZLVEPPUXBDIXUYFFMYEADVRWBIYXNULLORVTOPBFDDCDEDICRGVYYFDWBEXVYIVQEVOQIWAKTMLYXXSJBTHWCLLVVGMOUCDBUTCBSLXRQMXBFNAAKHZJKJCFVSFYLLWAYSKEWAPKOAIGUECBBOBISCLFWFPWJWJFFRVRGMNEJFIAYUGQPMWNKOWVSZQXJPTUWZZAPEYVSYBCSMETGHJJURLQDQGTJCNYOHEQVGQNZRDMPHAECPTMQECNCPUZPQXKTHSQKKOMMEETYQLCYNDSKBYARJKHTHBTZAVOSTHOMLBNSILWEWCQFWJPCECSZJOTGHKRBCVNBICKNLCVYOFGRYSYYJSOVKQJNAXAVBEJCXCQGAIWCCFHOFOEYYSOFHWSVWKMFOLZOVTISPATOYBDGKKFEPWBVURSPTNZBBEXMHALXXDADBTPWPSYLBXURKJYVJTXWXMNDXKFGLJKKRGDTYAHQYFUVQWGGIAWGXRXHBMGJVEGLGVGILQPBUOBMRRSJPLENIWKFDFNEYFYMLCOUNCYIFGTHWYXBTDJIBTSTUKOLYOGHMIJYNNSQJTTLJTOKMTSDMEFNXLSTDYKAOBBETYCGUYBYUPSLLPXDAYSFSJHWOUZEDFTCZSGZVTREFRKXWBHTDWGTSSASFFLWVKXYOYBXTPDNXWWAIFGRDRUSJJFRITQCRHNWWEEMWTTGAWSXDRJXHGXBTKBZMTZNUTHPFONCFVCUSNBTIZAZZGJOHTLVWLRRJIQSYVTBOCWBUCZPHJVAEOSNOHUXVQEDEYYQRMZKAFGTAYWEWJKDOGKOOWFVEPZTUJDHIELQOWSVAUVQMBJPUABLVQZMJJNQRBVAZCBCMWPMQDVRVITLFAPJSOSFZAPZWFGWMFITPRZPJJFNFUXDOLMGAQXYIHHREZXYQICJCGHIXIDRNGLFHTNNFBMZMTASAJJTBYOYENCDCVIDDJNYALYJMRHDKRHXPAXRQPBINPKGZMYHVOGQUGJJGTHGAQRNPXWPBHHSAHVWSVQRAIDWEZSXKQMRNAWCEFIABXQNEJFTTQUUTIZGYAXDCYCZHJLFKQOHSXTOJOTYFLUORAQVWAVKJUICTJLYLQMKCJZNZHJJDARGGWFTBMHKBPCVKHDXZZRYKVYUJMTPQJGGKMLHMYNLXVOZXQSYVAQNMVRCSGPYAYVZXQOSSBJJDAXSNGEUPHFCGHFPHTDSUHIPOXYEPPOKYGRVBUGMLTUXCMPLWEDROKTSSWIQXEUVJEZKHOZJEJDHLKJBJVKYMFCWJEAGILWVIRMMXJKLDITYQKDZRADGFETEQLLQPJGUEOTHLXXWOZJQMNKSVVZGYJKSAXWFWJDKYKLDPKBNELOBOPYIGCSLNPEMQYAHIVLOEYXJIQGVDMFGAWWZCRFXMPEESNJAVJWQNPSPKBACZENDADNVGZTSFNVHJSZLFDEHWEKVQKGOLCSNHAMRAHZTZKTJABCPSVDVLBNDHCLOCYCYTDFJQMTMJZNXBEGCRLKOSOVELDJQUYUQUNUPPCZIEKGYHHHBDZRRFGRCXNVFYJOXDYGZROTFRCACVCECLCNOFLRMIHYFMJTNMLGKENYFWBTVJIRXXARROXAGWJRPRFSAQBUPQSVESRQVHPDRCZSELUUPOKRZYQQHGCIIGBDFUMFNJJWRUNPKHJSBDNIUYXEPUJIFWYJKHCYXIJTOVLANBEDVNGFJKTGYGNNPYNTBOWHOJLMVQZUDKISTDSXEIVJBXBIDKGRNLXOXAFVLTLEUZACYCAYSLYKUHBYWCWCEDCVDCKMWTPTQLPNEEXFMFAOKWUNATPAIBGDAJQCYZHUJASMLQQSEUHMZXVZUJNOFIYDQZCCSBWEKPSAFECYGQCVHUWLLHHQLEQKVYCGTZXVUATHRAHJBXNJFQJOJTTPAGIAKBTGOKGUEDVTIGABWWCWSYJDDEGSUMEXXRJUUARSJVFPFKRRVNGFLJOIWMVDTJONYQCGMQQZNPGSDWOBHPIDTS",
        "EGMVWDIJMPRUQWGOVAATDZZNCFHCLIQYZXJIAUNUHFZQUDBSTQVRLMQRGNBLZNYBWTEHLMERYOMQINDUGJUMSCVAIILOSKRUPNLCUWRJSCIOSJUOHBJUHZAHUWREHLYQXCKZTSTKIYYFHRNAGXPMMSNBCWRAJGJNEMIOIYROTNUCJEYNEUBLGHFFJYAVLQQWOUNXAMYINVYGFJHLIBRMSHCRXXCWGSJCAXWZCWXFRNYLSITFSEXYMJUMAWIJWOZJEAFLAAUIVQDEDXUJIEXEJXIWYAAWRDLTQLKFSBYENRQALAGZJIWAHGXKRHHGJELWEUMYPCFQTNMAVQRMAQFLNFYSWKMYXJFLUFSWOFYYTZONGMQFARNXBZUMJXXZPXMXLPCTOPUAYHOFKRQDIEVGNIEXKRCASQOMBUEURDOWPBULWDVLTMRDOXCTGEDGETCIEDCGDEOLFKILADNJXTVCMZTBZYZFKAAAIUJGFYVFSMGNBOBHPAKLGNQRAXNSGRLZWTWHIKUTHOWBTHMTBKFPAFHOWFZCXUOFZTMTZIIJGTIZLLKAVFAHIEOGUEHBUKMBXQGOHEMQPYLGEARGHEIBSFDFYVSQJGMVDDMUPJFLTPEFHRQJKIIJJGTGALAOESWNGAXCJEMEDAWWTPIQWDPNSXFIMOOANLQYBPIMHNWFIFASXVRVHEXVTIDUYESEFYHCXWYNZLICRDPJXDYKDYYPHOPEUJDGJAAJACARQJXKAMRHPZYOWAHDSMGVNIMVLLVQSHCPTPXDOOQBXSMEYJCQSKRHDXYVTEQLCEXMYJRSGNXOVFUAYWJGRCJPHOXUTNOIKVYSRZSMWEPTXAHHCWJZMVBBTGKARETMQAIXBGZIJTYTIZTNGVJVQCMFCQQBTQEJDNFOFZAYXUPMBMFEZALGYIHYREAYWRNIJOPFXPUJWLARWENKOVWLPXZGLRPLTXFKQFPFWLQQJKJMPQTSECTHYMGXNLYRENQCDBNGOCFFWQZPZUGBVZHVMESRGLGEFWXNGQAKYIJZFJCXUSTMMFBOEVHUIRSLDUTWUCIQALCDZAFKISNSFQHPUXNKWZLLERATBPFIRWLVKRYVGGDHZFGANXKTNLPHNRHNPUSEYARUWDKIZCDLKDWBADCYQCDWNCCTRWICLXRHLQLQYEGLENGXPTAARZNQRHCAGPGRYPYJPDQLFOSWUBHOMOAYVDBKUWLFOPDVTULUNZQCJYKQCDKJTNDBMCFCXDPCOVGIKFIAIRBONPHQMQZJABHAHMPQSOCUGDGIUPMDOSLGOKGSIRTKBZMXSPPKXTUAOVAVBFIDIRSUUWLTKLXRQHLQCQNPQMJKDIJUZQDWROYAGARZKQRKOEUNUSXUVMMNDWCWVWYCCVLEFJBFOICANBYCMBJPUGXMTJNRXZANDWVJNUVXDQSPBUBRDSIZSFQLMDFHCDKXINCTFQBJSEHMVNSIOTFOZFOYSGXMQDVKCZLWOBMSIFAPEEXZNKCPNLZOCINWJVJAQLGQPAUQQLYANDEUGTNCQJLWGDDXIBIENWCIXFZCXMUBYCPOZCBSWLKQOTYCGGKEFOTZIRKLMFWVGARUSRJALTGHUOVHRWTQDCJXDUEPTXYQETCAVKJYMOTGPHGNDLMXIPUWYNLHSPKVOELBUTGSQQIZXQYQCBTTDNPYDACDYETWCTSCWTVENYAKYEJLQGHFGOUCLROTSCVCBWZSARPLJUQEVBFOIGLKNBLEIDFAFDOHIWWDNZVNISWABVTRMJDUQLBJOEWTTHUXTFENPEJCGTMMEXAUBEJURZJYQJVCDVKGDCEHRKAGOFUGUJQKTFGNFIMHJLOPGJFZLBIDYINUNKXDVCDAYXIJCJUSZPPWPESUMTLOSCVQLGDRMZCCIYVTOQIBHFPGZPRWSWNDBYREQANIOIAJJBBDIIVLIUICBQTXHHTRKPXVAJSGPKEANZXAYKPOYIKPSYSYTTPLNBHZNJEDHDUBFIBVKZTVOOLKNBUCMBSMTNRESTWIHDUUMSV",
        "MHGQCZXVSBYZHYYWSTCJSSWLOVJQYMUHGFBCRSWVWAECJPYIHNSCHQXIOCEVVDUOEMZNMVGAUXGFKLXZLYRRHOXYJBKNVUMCUMPAWXJXZZBGRBQOMMLROEZOICQBFNEZGGHUGGBKKZHLRTDJNISGEYIHPJPPLNSHNGDROICAHAJGSWSMZLZMSRLKXTSBEJXFGKHFDKUMTNZWNBKLXQBBNQKVVNPXAUZOJNNIKHWVWJHJIXIICNHHRKRWQZCNHRAHFABTEWEIJGREWQNPAUULHMECSRRDIQPTMGPJCCSPJTKLGTEBYBREAFELDCPERJJAMHPZTXLJUALJFQGAEYYMPKDZTXZRHHTKKNCJETYRPAHREBFMXZPHLVZWBNOZEVKYWUEJQAJGNTZQCIRMKFIWDCLZGEWTWDUEUWHFTCGXGSQTGCWBQHOBIUMIWAKBKNAABRTHDHNLRHHRAWEQKVXUNIQXOXUUBTIZYGAVABYWZKZPKCCIRWVMBGJKRXTIXBGGLLHHMFIHWQVIXPKHTZYJTHCBZSTXOMQOGBHHFTCONVBMRNNYHCPWWZLXXWUGGQLNLYQKJHLFVJPFTODNZHTGXENMJQQMILAGAJNFCLUXTAZJWWMJOZJZGHBWXRHVELORXGGUDQAZUSCFMDFXRELHDQPMQZXZEBBIWAYCWTSRVOZSFNIFCASGGHFDTTPCFVORKRSJMOUXIVLCMJFWNUEVVUUBDSODEDRSKBGZNNGKMKEKIOCNOCXVFGEBWKJJCPHJXSFVHRANKPVBIWAGTXERZSJYZGHVMPTHANJFUWMVTYMEFIWNKRMYFJCJSURDIDWYMAGMSVGAMAWAEFSGYLLGCQRDXVVRBISVIWPXJWDQYQZIUOENOIRQYSDVIDNYJXRMICQUUQWLGYMQJUCUGDDNUDDQXFZVVFKFVMAVMPYRMNUOSYUGJBIUDQSZUMQXDHACMJUVREWHRVWDYBEBGNMWWYQPCMQWVZCHFPFFFRKDYNKQMDYUTYSYBSXVVKSUYGJZRLSQTJYSKAHBAOFRGJRKLXTBIKBDDZSMAYPITOJIHQTNJLEQOCYVUOUMTJFVGGUWWZCOCCEFLSPWBDHSPRDJMQEUJEPKNMCKIOOCKTAGPUCQOUCJIEUWDLLBIPYISAGJPOCVADNECPJPCLMYTJEPBQOSQBEVXQKUFVRFWPTZLLMNAEXYZRRFHZAJVNJWQBQIAVPGEQBMDHUNADCTQVKCPVSHCVQRFQFERISBTIHPPOIUAHIQZXHDSVTTHQAJWLBFZWQFLTCJQCXUJVMKQUBCVJXCHNAAVBHFHHBHSJYEWMKRGJESDHMOVLIPUYOMZJUXQYFVSDKKVEDCUVVFZXLUVUDBEWFHYQKHPDLUINUWPAUEZDWKMKYMIEYLWRVVJHJWZSFPHNRPJEOUZRSWNCQQOUWCKUMRKXGKBLOLEYONGVFGVFLANFDYXJKQQWUEPLPCBZQDHUUBKHYVGIFGBFOSHGZYEMGSUVCCTFXZLPYOWEGLCQPYSDNJNODQHEXIMTPPCNFTQQYDXFENRSEHFGXONTDOMLRBRPGBETNDTRTVYASCFDPDRTBHPLECPQYLYFWHGDKJUSZPBKYSPIXRLOXDFYDSKAYZVJRWRHGKVNZJFTVWSLHYDYKBGOOUZZZAANGJWIYSKDUTXXJBONSDIYASXDSWMLFOCYPENPQODQPPCDNIALFXVJYXURBXQCURTYCZWDMBRALWGIWAKIPSBEXNJQOQELAWSLZZXWNNDQGVYOQDBVJFPBPFVUKEDYWTKVJKVEATUVLIZGVORFGRCAMYZJCSYBUYZZVRQWBPAGDMBPKPJWGJDWNRYFKRJWNJDTDGCVPINAXZJTQQNLRZPTVFCYMIBYHUIPXYSRBDFZTPEPWTVJIGWUUBYPUYVNQHHRPEMZLVXFOVABSDLHBMCOYQYFDHCFBRVOECPOPOSSQGBVAYJMRQDRGGMPWULLWEKXLBZKFOOKSQRXYQHTBNOJAZPWUTMCRUPCTOPXLGMMT",
        "CDCSZIALABYIWLMCFGWHYLKGHQGVBUSFDNGPWHIECAOGGPSLRUAZWUIMEPNMWETVSJYKYBOIPJVBCEWDOAEZJZUHZTGESIFKICZIUYWNOLOVCXUQFOCUAQRTJRPPQDMRFINPMMGKKEXFJZTNEWBXFYZKHZUWGUVNODLOZUFIRATEBMKVMHONCJZKJCIYDCFSQFOJRKSUEVBNAVEEJSEABWREEKAZWEDHEBIULNQZUCOVMAQLVMCTMZJOFTSZWFKCIBKAIZSERPRJJUITVSUAXXWPTMPXMIEXMHYYUWUNJVRUYYBKAFILKVIIQOXFVAQCYDRVVJDXOCWIGAURTBZFWQLIBSLQYTDBIVUAKTQTMCRDFBXQAXZCBXZFGPCXDONESARFSFMIGVSWVYCTNTLTWSJTOFPIAZKJRVCIUSDMJNGEFOJCCCWTHFFDSPPDNUURKMZSMNVFTEQAWZEETPMFMCMXQNTGSZNVSPLPONFFNZPGOYRROJGEZJXNNYEGLGOZCTYDLJOEGXIJYYHCJASPSAURXKEBDZQYFTBMKFFIFZNQRLSGAKGATYBDUODENEMMZIHRFVGJFBOXMYCCWTBLYOIKPLCZENQUPTYXMFDYFQCBQAOHFFRYXNLZGYQTKRFZIGISDTZWJOGULTDAPKPPVVROLBJOTJIBNHLTOKXRBVKRRWWYZQPRTGPFLPLUTXIACAGEKAGGOKTMNAKPDUWXMTHRMZFNQFGBABZWJQZLNNKSLSBTLLPEPLROUKRLZSTYPXRATXBTBTEHPSKYBSREZJUDGWBRKOGRKKVZWKZYPKKRIZGKXGSAKQNNLMMVTWRVBKTXCLINPJEPYETEILPCSURXBDXQDCLUBQARNEUKSXFSVZFEHXWDFCKBRZUSAHSZLELKUJECTPXONMDJUCGLPMJSQAMLKNZTDSYKGYUNBOEDCVFPCIIREHLJBDYCJQIDCGJBCBMWQXAWHMMUHQLCZLTYOKMLXUGIKTFRXLCOUTOGSEYOVGKOQUGWFOTIGVEBXKKFQJWDUXYQNCOURCTTKLNOISKFQUWYZSJRZACOPZPUMBRNPHNXFUZJIUINFNIEIZGCZMSVPSVKCETRXOZTPLSMXTRFQAMGYPCXQPXMSNWWIDRYLYCEQEEHLSJWROZGBYISYWAZLWGUUBADVICIHRDWVXVXPLWJBUHXLLMQEQWOVUIHLDMCWWDNQZXOEFBMVTCQIGUSBSEJCPHCMWDGTVIOIMQAWSRWZXCWJYASILKHEGNKMJTZFGJYJGKXIHFBFUWYKBFOLBONRMWLRNSSCAGXXBQTVIJMIJTOERXPMUWIMPABZHHHNDICRRJULEAZIJKRJDXBXWLLQKPXVVRVBKNFVTMRFORWITIQUMGHKPDFIYJTNDLWNTMOXTWKWDJEKPGUBFPUTSSASAFEJEOZJMMBOPAVAFCYCDEUBEOWWFUEYKFEATRJBKNWXHZOCZIDXFWVGJKPMSMPZSHYHFHDOQAJTXEIEENFIHKHQEGYBZSVKFNRFMIXRHWDWEZYQGGCMDQYIRLJXABUEBVTGEVFODLRMVHFZRQMODGRFPOJOKQKVOESUVVAWRQZFHZUMVZUDDPNUUIHHEBKPTTFGZQXWBYTMZRRBOXSRJXTHVHHYSNLVASRZNMIQNGYHVTSSJNSEMERCNNCSHRDKUWOCGHGIIYBDTNRLNMYWKHHBVCOPASRMGJXDYTOSRZNBNAQJIQKMEQXOEGUBBBZGBCLTWTYICMHFQOUJEBJXWWFAHYFVCMHNLHGYVVZUHVOCTYRNCPQPSIYDLYENYBYFFJJQGXJONTKONMIMHKULHILIJTKUMWEDMLSRMQRKQARMLKRQLZQWFBWHKUOWZMOCTRFVGMHBMZLVVNCKFPWOAAUIKGASQHRMQEWXWAFRJLXRSSDWFRNOCUPCODHPSKLHQTQOKITMVNCOFZZAQJYASLWHOCCBCKUCYZDZSGURXBFDISLISXJACLXIOCFFYYOLTZVISOHKZVYQJSRRFEURDKVPNK",
    };

    {
        const table_columns = [_]muscle.Column{
            muscle.Column{
                .name = "pk",
                .data_type = muscle.DataType{ .TEXT = 2023 }, // Longer keys
            },
            .{
                .name = "int",
                .data_type = muscle.DataType{ .INT = {} },
            },
            .{
                .name = "real",
                .data_type = muscle.DataType{ .REAL = {} },
            },
        };
        const create_table_query: Query = Query{ .CreateTable = .{
            .table_name = table_name,
            .columns = &table_columns,
            .primary_key_column_index = 0,
        } };
        _ = try engine.execute_query(create_table_query);
    }

    const rand = std.crypto.random;
    for (insert_keys) |str| {
        const insert_query = Query{ .Insert = .{ .table_name = table_name, .values = &.{
            .{
                .column_name = "pk",
                .value = .{ .TEXT = str },
            },
            .{
                .column_name = "int",
                .value = .{ .INT = rand.int(i64) },
            },
            .{
                .column_name = "real",
                .value = .{ .REAL = rand.float(f64) },
            },
        } } };

        //std.debug.print("Inserting key: {s}\n", .{str});
        _ = try engine.execute_query(insert_query);
        //std.debug.print("insert_result: {any}\n", .{insert_result});

        var metadata = try engine.execute_query(select_metadata_query);
        //metadata.data.SelectTableMetadata.print();
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.deinit();

        //const select_query = Query{ .Select = .{ .table_name = table_name } };
        //_ = try engine.execute_query(select_query);
    }

    std.debug.print("Test success\n", .{});
}

// tests previous bug wrt divider keys
test "regressoion test 2" {
    var file = try helpers.get_temp_file_path("test_stress_random_operations");
    defer file.deinit();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var engine = try execution.ExecutionEngine.init(allocator, file.file_path);

    defer {
        engine.deinit();
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) std.testing.expect(false) catch @panic("Memory leak while deiniting");
    }

    const table_name = "stress_test";
    const select_metadata_query = Query{ .SelectTableMetadata = .{ .table_name = table_name } };
    const insert_keys: [7][]const u8 = .{
        "JLJCGFUPJQQPHZSYLYKZVFDUJDPDEHJHJAKOPQDFJDBTQKTVJLTAWHMHSLXFYFCDJYWDFCBWFJULCJNXPSUEJXIFWVZPDDKXHFSBPKVTLLNWYFANTWLLVVFHDFTDUZNZGFJZDPYWRXPVONHLDUFJARBIFNVYFUIGNDGSVEAHKOIQXWFNFYVZMIQXJTCELQXTJIYUIGLZSQHQHAAAHAZDAYPUQWRRBYXUXJDYJMEIBFTKVCUMUXJPRHUKEFGMXEJYKGYENZWPSUQLJLUBJIAPFQTFNAUJXKQREQFHFIHYCNPEDLGHPUAWKCAZRBJNFKQGRTAPMUSNRTDUDDMEEYZKTIQWYAEDARJAQNYBRPISOQJDOZHLTLEPCNVXDCANACDDHEAGIJUYMHPWCHQVVBAQJQGETTBNSZPENUIRZLYIYHRSKXLXVNBXBUJMAHFBWUGHCHPIDDWDMEKCDYFRBOKJDRFQGWOJMNASMWBKAGNYRGAOCPXICQZHRXSDZAHTKXAPZNLCMGRFNYVNORZCTCSLGWZZFQCKWBARIMJRRRDSZIFDBFKZEOUKIUUNHAKVCYWMFJCSGKMVICLGQLJODQGIUMAWSWGRWWHSGBBDZBBTKDIFREETMMCAPLCGHLCFIFORKBLIBJORJNQNIBIQFDDHWLVMTCABTMWNBDUROBITULTQLFTSKNULFHULKKFBPYTNNRWPOKDFRWPRAVINPDPTEZPMQVDKCOBBKRGLGRUFCIKJNABAFPNYSJDBXYWTKRDHDCMPQGKAJWXOUHKNUHFDFXKKXLGRANJVGJRVINHLNKTFEIORJQXTCPGDUIAPVSBAVYELRYOTHHZRKKPVPIVNERAIQRXMNYWMMQLTKZNUJSHVZFHCDGAVABLYXNHAILGNFRINVNVUVGIUWDVVBNJSPAFLBDJTZHCHODXHOHRQALVAWSCKFTZTIBDCZQJHPOSADXMYREJVDRBXVAJLDLIRQUYEWRHHPDEZYQPXEKPAAUGJGBZBJGTAWFVULHUQPYOTGDAFGLEJDKFAYBRJFMNAGWIXBPGXGJDIHPPRJRKJAWXPOXIVPTYAHLVFQSYUCYYBHNICGTGZWVLYLOXRNLQLPWMUKOJIBKAYBTDYYLOEZYCXUUDRCMLXELPTIAAYHIUCOLOEVBYCBYQGGMVDYYSGITWQDOSIFKULGFIPOQCCWLEPXWXBOHVFWQZKTPRFSOOZRKQQWQLHEMZDZLMCZPBLTCFKFUZQXFTFZKMWVZEDWDTTZDWNHALSXJPGRGXFDCPVHSLTGEVLQZDHXSBGGLTQNLXABDWJTUOPQDROXPEGNHHNOFGTOGRZXTROWJAGDMTFUMSYPYWNYRHSKSJCKXSFSNMZQUEJLYSLKDJQWJMGMJMCUVWVNBDALCMFBQAKTGBJJBROXCPGIIKEQKLOFPSBINCWLWXSMSYZRHPMYAPXOHIHGFRBQRSNGCLVULYRRKVQOORIDZAAJZBIZNYMYFVOQRDTDTIVBZBEKKPVUHHOEKHHKWCLAYVOPOCYLFHSVRYUKPDRPSEDZAZDUZDVKYQBCSIVRFGWVKNBVVJFFUZUDNCBIICLKJMTRGSMRIMKPKBNNVFGIHUSYROLTEVTUDHUTYXHOKUFDTRBGCGHNFZOIGFHCFXGWLUMPFFHKXKMGSIKMFBZZRWLEUUDRCAWCEMRAWBIKHIRRTCXGEDKJHHLOUKFSBPEOTFQXWWFBQNPORKLGCTNXMROSVWBINAHSXVPUTSSVHIUBVQHVDYBPNZSYIORPKDDDCYKLQJVUEUULTQCMKDQIYNIGMCYCTKGSFAAUJWBSTDJGGNTGATKQOYIENZVQPBOTGCFRTGTGHDPTWTDMSBQSTYKQTVYMNRKMSIBCOTJDZREDMEYMPMCPGLAHDPQCHDCQWCTHVOJAPUWRUUMNWCQGECHJAKHRMAEYHRQIWXPATVEOBLZEVTQCTVQAXJJOFKMYIOVBODRIPPEGYWNRVYZIQXNXKBUCISAZLLCRXNLMJROFXDRGQVMKEC",
        "DOCDQBXOGXOLTZIVRGDMPSRKACAJSHFBPWKLTQLJICEEXYKHSSVSBFFCKJSYRLENOFBEKWRQXYXIMYQAYNBUIYKSHXCLWHDAJESFDJBNSZDHOKCFFDSLAJGQWGVMISVWLSTABNHFEHEMMTEXZCFDVUDJFLXPMHICLIWALIXZDWRADHDZCCRRCUMSOFFZMZJERJGWJUAVJOSKMOONTECOAHAFVLZCZGJLLLFHONXYDAVGVKLSBZXBTGEDTRMGPWZYQEUATWPLTXVKKISQWTXUNDUCGNOQCROIHOOOBIFMTCHZIXNBVBNKMXPENOYMCBROUDCCSWNIPIHYIAMVRFTYELUETGSHGWWQQXKJDXISYOILNMOASHUHFJGXXDVZNRHBMLUGCAEOURUPFUIESOMCSNWJHAJSPQIBLWEIWFWQVVUWSXEGZUFCQEICUDECGJIWHLBMCUHLIEZJHPUXNZRJFOXBQOEQKQDHMWOFMSSVXZYEACMCZCEVZCKFPEMGBWLCXFQZAKEIGGTOBOFBCBMVINOMBYMTHNUHAFZGUUJDOAUJPIKUTNJBCLZVTHCAKAQJDUNHZUCPVAAJXWLZTGCRKSFGZAGCCXRCQBNPXPLCCUWMBPARUYMVAQUGYBFGCJTFFWDJLCAHOFWUYYRJYDPVOOSZUINCDMJONGYETLOTAKBJIOFGWWGCTCSQWDTJZTDGJLIMAAYJNEWDYJPBNGJFUJKOMPDFGNHMISHZWZGCJNTPCDMONYGPUQCSTOJWTZSVCMDNAACHPIDQZZWPOCESVSELVDKGFWMMZPJFJSXNYLJLKKIIVVCMBNDKDFNMJHJMWQOMEHWUBVCCHUGRUQJCQHLTUGFIOXSAUUYQQVPHNZAAAKXBPYTUVRRTUAEDNNPDSASQIPWJESVZZBNMRWAHDJXEZBHXAETTUOUVBSMLGWOVHWZQENYJFTSJSOZBHVFCSINITAGMWWTZKAEQGNNNVDHXHVHIAMNTOMFZFLYKJBWXBXMJPFKOHZZIWGKJSEIBHZXZQUXTPEGFMQUFAEKMJBUWEWGZRHNBAFMVAEDCXHOFPDZZDRYNSKXZIBRQNBIRSINEGESZBOPBITGFQICLRXSUUCKFSXZJORJKFGXPPQMZUPZTKBMTKRYWVRBWDAHMWCHYUVDEJCEBQVFPAAOICNFMBJTKUWVRTFQCYDWZYMHQBHRYWJOUDFFXOJERAVKRBNLZPLZLHQGNGDHLVXMTNZKLTWKXJEOLVHGRDOZMOPDVTYKNTZIJFIQFJNYUCAPWOYDSDWPRYTNSXSIFPDVEIJMCBVEJNUXKDMWOBWRNSBPBZMARIJHPESLSOMQHTFVSQNLCVOLCZUCYAWYFNALTUNWPYJYVQZSFCVNTQJIBCCPNJEYHFRNPFBIDKAHNQAYEZHUILTBFTBSEEUSSFSMOXQZFADQYNCMXPKPXOKQICOORVHETTDNZGXBADKOXAGGRMOLFQILEXTEPHZBJANXPSYFQYPLJARZZJRVRRALSEZPGPRRTXTSQUOJXKDRBTWRAVTZBRDJXOKNKDAZCARTWSLYDKALRLVBZAAJSIXCZXHDETLDRBAGDJUMZZWFRUMUXTUDWFSBAFCQIFPULKPMLYQPESXJMYZROINEZSAUJCQPXVVSMOZAKNCURWNMOUKUCTHFGIEUGEELULNOQOCUQRIAXRNZZQEGWGQPVZNRABTPHWTCHPFEDPLHPDKNVWXLTBIOOMLBGDDGTOARZLQKFSEGOMENYYEMPZNNTLZYFELFFBYRMGAICPSBTHIGQABGDRXQFALGQAUVRPXCXWZSAYJDRHKMMJCHEGJEBOJGOZKDOZVXCMZPZIFVGYMNTXXXBPLZRRVQQUQOWCNQMCZEIWMVBBRXAWPELYCPXSVKEATCLUFABRJXPURGMEHBXDRBRWSVZFMCOWLCQZTDGIINSUKFJITWFKABJKJEHIRVOJUTPURDJUFRJYIIOWHBEFKYUWESOGIAKIPHQLATVPBOHOXYDKKDQNMDDYGRBEDO",
        "YSKAZSRYJOYGHYJGFWRAITZWQOFPINKSAMGWOJUUTUYNQSECZOCIYRKFFOSUUMZXOPXSIXPZPYODMGMJBHFLFTNWMWTBKEHSCCEGUDRRNERXVVHHXZANUFXDMMAUVMQUYNQJPRHOVXPVXVOIDAXOFMNPBJNTDVJIQDCPWPVHSABWOUUQQKPYYCHVCOGFTFINLQNFGYQKOZRRTJCJXBCPSABDLXOXJWLQYZZAZESGPBLVOIUPYDSBMTGOGBXYZKSQTMNSDZHXMVQAQPPMEMBFTAPEZUICGCBWQGNWKLERATZLKEOWTAWLYAJZIBQEDCBMGXHOTYFAMUNHUAIPDAUGCEYZWEKNYKLIQYWUDXPILPFAMCRGSFQLPQBXUBKWYMOFBRHZIHVUESEOTGUDLHFWKXARUEOUFDGKKUMJQYIKOIKYFKSVJCXOITXMQYQLGHBZCVMXNWOBAYSMXMKBQBSTVXFAUOIZDJCQXSBQMEDAIKSXHOJDAAWBXFSWPAOUHGGLBVEZFYYRTQMVLYXLMRBLGFIUPNTOESJSKBGSQASLLRJGVDIHJPBLCHYODOQIVIVTQXFXLTDDYXJXTDONOXHWROZNLRKVRDCFKCLNFRFIYIEWJBKWSNMOGITQHHJJNXOBFPXOQFDZGUEVJPXZOEFWUDRMYCSLILUZRSIPDAUBOTXPVYMJKHRFVSKKYMZAIDCCRTVMMSPHTDETMSDCFGSAMPTJRGFIKGKPUACQYMRWRDWRLJFARVDRDFZYPNZIGJSLIIGOUDZHLIMVJPLJRUWNGOEVVTHCDZMOXZINXWJLIAYTMHUHUUMWWWASMQJXFUNTGBYCZHYXEJWKLUJTDIZXGEQZSSDJFWGWWHOILBSNZAZZEROXEFOGIHFOTCRLIMZLFNEDSVOBSGDTEKUJYLGPWTQFOVVXLTGFEDJXTVPWBFEQOTVJNQXSURPITYDHODFDSADGHPQFXJYPXHUDNWPRFERXIYFAWUEJNJLDFFGVWLWKKEAGHSMUMRHNOBUWDZINGMOUTCGJPIQYIYYNVRYCLLICMSWPZTDAZMDGQPAXSQRKOXRMOGSFUFMADGBOORWHBMYTFPZFJOOEPFQEGVIODVLWROQRSOUEQWTWNFETOBBHGCMDZEUCHAHHQYGFVQYVOCVCVISJBHDEQQHWAVMJNZKDNRHXMHJBMAIHOZVYPQALWHJZSNQDVBEQUMQTXXXZXAPDLGBYGLNUVRRTLORTLCHRJQMVRRZZFZKOSSMMICYGBXWUQXDXDQMMABHZKQIXVONYRRECQLWOXGDTWLRBKOVPYTSQZNACGBDWIKEIVEZOUCQQFITGNGYMSQUEACJCEWITTCPMMYLRZUULXVYWILAKUBCPFQLYPRTBEFCWZAZORBAOOKUXVULXRBUYITLUONVEKZMHLGHLLVEGBDMUADQRITTVLSCENDCNCHLHWXUYFJDOTGAIINMBRMQZBXGBIOAJACJDDQTACWVLKJIENNUVWTMPZCQFBAZDQMDQHNPJISYTMCOMRAMIFPXKXUPHPKOLEQROFGNNTUYRDTLNNHUESKMFOZVBIHMTNAZGRBWQEWYFZHVLAKRHVKESKJVPPHOVJEQIQCDZZDLLOBPEOGTZUVOROEZJOMAJMECAXAXSWGATSRNXFPGGJVBHJNWMXECTRFBNOMLANZIGLQZZUFOKUIUNLLMOLGWEHTTTOIAMVDRFPDGUYKOWGSFNOZRUGEHXKIKSSEJVELKIBXPQZDJZDINYCKJOQUZYGGTHCISTZFEYNUJBELFQMSJMKEJASOYMLKHYMVNHAWNWUKONWGPASAILSLBTAYTBIXNIBMSWYLGCPWDUFOHEAXZLRGKKPLVYNBKBIZURKBSXOVANQZXSCFOGYGQINLYKMHJYFSYEEFKIOUHPVIZJBIKCBHRYTROQQAKHQGWREJVIXEESLCTWFRQRFQHXEQZSKYHJHYYSWGJLCZUTSGPVFAGWXOQROEDEGFLYSQBJIHZXNWJBKFBLSBTLFOSAFZFIJOR",
        "WGRXHYZAQPRLFZIMBOGIHUWQCRDORZQYQYAINVOOKOWHLTEXLWAOJBCALTDBAOGYYXJWLPFOQAPOCFVGAFWABOJSFNWUHLLSGTSGCWRJACJNEFYNDIGKSKDRHZGLDQBRLKRHXCHCMNHAPJLQZRVRNWIYDAPCLBUXGCPRCCVVKORPMRYXVBMTUXCWBWRUTLCRGSGBHYVZVAQHMOZRTKDNEMHJRDJPLAHIKAKNVQKNNCEUUZJSZPTKRRKKUUKXXQQWJCPYWJRBUYOZBPQHEQDVLXJDQROQYSQFCYIWWTGEGZOHDJBOGJNFLYCMSRFBFYSHDQINBRYAFLQZQRSNXHVQLAUIKKKOIMMZFZMXANCGQOAOFSEKZCWURPCFJKBDYGRALPOCCBCJJUHZUDODRRWZACNHBNFKRNSDJWAGBWSOJNHLGXXWDEVEJXBPZKHFHSFDWNBHZYUMISQAUYZJSYHDELPOTYCVKMOMZZVHCDLCTZEQMBAAEORRDGVGPAIDFZGQPFPNTPXIYYFVINDZOUQTHBTQYUAWQKDDWFJIRJSGWNSDGSMESKKSRCJQNPIPBUYTPESGLBVEKUUFDOFYADRRPMYRQEIWYLTBCSIVTUFWQZFZTMYUSTQCHXOZTYUSZKYSTVNUYKPMMJMVDJCJXTVCQHFGCDQYTFELBGNVIBVUKCITYLIHMYPIFAFPHKTAAJGHTFMLJVYPCRYENWBSELSUSHILQQRSMDYNFGBMVBVPXIIDJDLMZNLFBSOGVSFFODUECEAGCWZTZOTQKWIEJVVIVYTSMRKLZSQHDKCOQTADFWPLIBNFDHDJDUSQRNJCSXHHAHMFJKQJIVUOQVAWMKVFYSHROMWALDRLZXMEIOZTZTZGRPZWROMGYDIADGQPGPTSBLFDKQYZBMLCBAXQOJGJRJOEGTNYOTONDTRPWUCQIZNZYJKNICANMABOWVXRVGHTOCECXKJBGQLRGCOUXHQNNTYSXFCDHAXJIMNFEKRJYJPNTUFFTKDKLNGJOZWHMFGNIZBNMTLZJJXTRHSOTGGFMNJGGBUGDUBPBAVWWZPUXDNJMUDOSLIOASXZXLZEYIPIASQRTQPRZAMJBSKAHHRENVHSPMRTWUAPNNXDTMGBITVDWOWCZRVQXAWPFLKJPVYVKYTDSFCORJITLNIWYKSAFFQMJXHZIIDLVZGZSROEYALOACCEHOWXBWJTTMQANOFLNTVPNZNYPFZUINAYUXLGLSBUFOEMSWQOBCZYRBZIXKIOILQBQITCCHNQBPCMSVMBUVJGMQJCBTYEFNBKWYCNIFJNMWGYVLHQATSYNKMEXRYWANGKZSNBESVAYPKXSGIORVBLZSEBOCUGGHUBWIQIROSUFPKRHHFQZWNNYSMQQPRUKOJPFBNYWLSWAFHIDUJZERIJLKOXXBBBPPIGXDSMVMSTQSPNAFRGRYPMYIBLDGZUHZHPUQYJOOSCUWLOTPAXPDJEMJERTXLGNRXEATRGELMTCPIPDHRHIYQBJQLQGTECOTOUHVNEZEOGWXDTDMTNQZVUNLRSTFMOULVPBURBFRHNVJENHZPMEGIPRMVWIZTPWLTAJAHHRISSBYPNAIYYYMBRMZSGBHBZSGZBUQOPIYSTUYJTXBHHMZXXUUALNFBUZZZFVMOISCIBQVJIXJPOVIORGVSTXDLAAZHBAENPOBGXCETNUORSTPODWIQJQDSKGHGFOKZSTLLJKBEZQVVETJMYICJBHGRGLUNYDMHCSGWZOTDMFJIXSAMRCGLFVQZWOSSYBFCLGAYJYXHXISNCEQKAIXTKHHCKQZWSQTGFITONYRDLXQCKNGODWYWSFVDFKODXTSANFIIOYIHJQIWVURIXDVATBGSCVQVVVRHDPVZPQNDCMPRVXKJXYVWNKAFGSMRJNRUHXKVRMNAXEAOGFRBTKMTCWCMAYCNCARZKGZSRJDEQRNEZAQRFPPZSLUQETBUCULCAQCWWVSEODWUZWYZLEOAVALQGRZJMDLZAFVOPFVHGTCLQPTAQWAU",
        "FJRYNADNYCYKKHBYODPFOUPTYDHBZVSWAOWMKYMNVULLYDHPMHGRIQHMJXGMQGDWHYXJMSCYJBVMBGFBPJYAYUUAJTWEZPBIFQQGEOSIEGQIVKZRBGQFRYLTXSZHHEEIHNMACUWDKVKZIZCKHRXWXHUXWIWKDDLUIKNPHDCTOLHMDAIYJSKSBCTMTVKXPXOOLORNHUFRRCLLAYHRCCMVHLKYCNWQHSKFLMJOLWADYCJZICYGXTIDOOWQLPGFCMDTTFFODJKFQPSZFPWXLWROAMMBXZUTQTXFINYQEIAMKIPCHWVXZUWQBBBZOXALAVWDDQKCTXUEWPGNMITWPGDLXBCBYETIAHEFBZWATZTVWXTXQZPTXUHDJMDUNYFYRUECCGFZCMSLWUTJKBZUPCDVKKIMHXSJFVITILOBEVFCVRSJEPLNZAXRQUPMPRBRMUTODMZYRHFEFPXSCMUVHWQGOBMNQUWYBXPOEXECCZINCZIXAKUQISZBWZVONYIIWOFTKSLPSFUMVHTYGRLUQIHVIETJIBNIDTXKIGOEWRQNGTUDREEOSKTOTTCCXTIFUWYXPOXTXYDJSAITRZVFSIBDUHOKOERKPBBNUYRWXSCSJSLOWNZHLJZNZFPXWFSVUBOIRKOVQWKFVTRNNIDUUXNOONBGCNWBNPTLLVZNAWWDZRGXPMBOZKIXEVCACEQSSGQSSQKOWALYONFLXBGXUXPAMHAZXEHUDEYUSNUAMMBWPVYTAWVPOOYXJOAHCQXYQXCDYTQQWGVKEKFGBGNQTKKHMACJILRMBGUKKJCQPZPKLDHPIPSLJEFEUIFQOEPPYDWIDQJIMXYOCVGWBENPSCENFJLMDSZDQOCHVBWSJERQPEWXGZLBZQSPVGHURCFXRGEQPNBFXUOEHCDCMDGAYPYEIVPFOGSWHLSUTUFLSHRLFFNBSULITBIICKCIAARMTTDLRQWPNYSCMWFILSEAAYXYAQZWLTZYJHKFNVMVONQAMKYWCFWGQSIHCGQYWKMVIQROORYYBPHTRABKEDTMNSSAUGEGKGYTRZOVPLGHVMZHSLCFDSXKQTNTCWINIDZVRFPZKBWREREMNZPQRKYYOQJHOVNPKVMXIUACDZGGNBAOCLZLGJHMMWFYOGSWLHBKMXDLQOPGLLZYXPTWRCWECNLWCCICDQNUNBZXNMQLVJXEBHIXNAVYSCGYQYRAMIBKNLNSTMGMQMWFFFNJOWPWZBRJJSMIFOCLTYIFXBHQCIVYDSLOELENLFDLYPNZVVKARGFDWGBYKEOIIOFKWUZNWUEMTTEBTWOLKJARIXAYKSIULIBFVEDEVBUNMLHNGDSNWIRPMWMSVTHYIFKTYAACJPZNEDJNPOLICYZOJUGACQBDPPGGZBTVPDBZQYRLZRHOBWIQYZDSNMYPFHEPYJDPTDFZSSDGJHOCDJUUJDVBNEQYSMAOCCJPZTWHVVKYNGOCVYIZSDWYXHKLFNEWQECUZMOEXBFYNJPTSSYODFFXSWKREKBZJHWUECYYLJVKWNLASOTHBQTALKWXXHJOIRSZYJVGQKRNLPBCFRLJHSGIZVJLWCTANYJBCIWPEWXECDTPLCSXXBSUESEMXZRHVEQSPLVLSTHMIPSFKKMBIRGFAMRZDYFDVFLAEJJANYRDURHPSWKOTRIZGQRVMLGUWPSEGTGQGSPNJROJSUNWHABTYQXGFUASYMUWCHMTWIORGBLAAIDHNORGWXBMCNVXHAQTOSGTQOSLZKQRETQUWQEWAYFGRSVFSYNELHEIRAXLDYAVGAIOHJBVLTUEBKFHFUWUPAUYZQKHJLMTMLDFOBRVDAJCUWFVPQQLSHKUQGIIOHEVQXHZKTZPCSJZKATUCVEHKUQGSNDYJXVFMTJBJOHYFIYNAVMXSEJNZOWEOIIYJIPLXJJGASQNRLIOTEKNRHUBCZSAMQGVMUQGJRUUBUZANECANXTDPDLQTJIGYQDSHLDLQMFWKETMCTTTQHEWSUFCAAOMFYIFCITTKNPAVQJCYMK",
        "LECCSDFKCLRIWTWNUCQWYEJCTJGIYVPVSJFDGKOYHLXAMGQZIQBONAUJNZWEEEYBBQJYABXVDXJQBMJCDMVIHOFJXOKQGECKOKNUUYHCKQMGRSOBFFLUGGINGLMCZZSJQTPMKVNRPAIXEHLIOQLWJFPSSLLDOXHWTNDTMLUAPQARZEWHQGKQORFHDPFSKCBLGPKJHEGSTAIOMOMFYNHYKKEFDHTTLQGMNEVNPMRGCRKIUVWVKTVDFDHMEJVOQHJZLDPALUXHXKZCIQECPQLAMDOFKTLVPSATSZSEGAWISMUOMGQDMRLOOHDFSGQILOENZXRSFALPZGMDERXSTDFUYROGPWUIJTTMBDDAMHYQKCJWYGFUGASPAJWXAGYYYUYQQHGUSVWMTJAPQEUEKMNRZHXNIIDKPTWYYJQLDVFIPTZCWPSTLUVIIVNNGXIZMANXTGFHMIIMTCESNAABRWJUUOUVJHXECWIDEKXRVQPLSUIKMIXMVMXHDFVRAHJNQEOQWGFUZERZOVNVKWLLUETAYNKSBISEKCATYCDDEALASKGZPTAVBLOWKDEVYXUKDBAREIFYTYBTMFXBWCPTYTQZLJIPFQOWBRTIHMQJLHSOLZLKNXGGVKCEPRVTXFPRFDJRIKIIFLAGNJBZJRXIGPQNDHCLPDUYEAVCFKAUNBMDIHGHOEPUKBZQSWXUPIEXWNDAQMOVBDGVGALZGXLUNRFADSADLEXEPOKRAZMKTNAKEQHMWYPNNGDRPDZUZTBJEXQIJBVEJHVLRVUZYMJANZNSZFXEFRGLLBCVARYKXPBFYJITGGHWYTUUYBFLTOCDIWRARVLSIFEUUQZDHKEDOOZYBVDGDTGNQVKRNXINXVNCIVQBYYQXJVZKUQVDPJLCLDVWYGTBORRSUHLAOUHXNUJKBMURVGIWHHFYFIWXKHHXXKYBJTIUUHYSKQTGZOJHNQDOPRNRJXMGFZZFLRXOTMANACWAMWMZSOPDQNHGXPTTTSTFAUFVNSVWUNQFLYJSAAZEUWKYITAPOBIMQKYBKTIQTITOTVFJKFSXNYFMIKVFNJCFFPKKCVUWPSEWHITMSNPVTPVZTZVEMQLOMOCHGUPOTXWSSDJVJRSMOLOFJZDQAWTVJJZHBNIQCRWKQJYXZGKCVKKZJCROXCYLQWKKJMQRFRNNVZKSHUZBESGPDHXJEOQLGMKREHUOHXZDMNMIBFXUSMYUSDSWYVMKVRDMPWYRYHGTCKVJOPPIUUKRCTXOTTDVYKICBKFYPWYHOIGERLUJMYVDQXZKKXDTPKKFRJIMPEGVMUJZZFUBDFKUFVKTNEKASNOYQGMWDEITGXWYPDYMBPEHZJTVUETWAAVCNKBEMUVARBZCIQANFGYJBMFWTLFAYMVOMGEMCGOWOJEOSNIMMNDVGBDBXIFQYOUQHPPUDMZUBUTMDQDKBGNQVCWAQNKOQJPIACRGOOCGXEZWDCQKYYEFZADDAPGUCIFPEZXCQTTLNLQSJVQHGKSOYZOPJVLLXHNFPFHMGGNOMRMGSWUVGERVHLEVFBPLYWRIEJHOECMAFDPACSLMYFHSHLVSVGNUBVLHJVOBTVZMYHPMWQLRDDDTTYORHFFVTXICKMUNIUVGUXLWEUHXGLLZIHHRAOUSGNNVRENSQOOCSCRZIAVQPCSIQUINRFDNGFRTWJTVZBCKDGLYNNNFYKMFCBMZZDAPSMXBDRTFUOQDMASLNBNDRVFPACZDKPPNCIGBXNENPXJYIBJXGIOTZAMQJUONLYICNQHJRYLTZLTUOMVERSBCYJIXWOITCXQMLLGREOFANZAOZMEACZCYPYXGWVYTCAADBBANLLBWBZTDWYJCPFHSWRHJCVAIQENOODTGWXOZWFYZRRWQYSSWWKWTROPLFBGCCUMHADFWWPUVGNXDFUMKWTCCDIQTYHJECXYHMEFGXWNEFJIRPXVCUMTYOELRKQHDPRIJOEMSORSGHAJFZZCRWOTZACDEFFOVAPYEMANTRIMXLMRHERCQJRJERNP",
        "SKGGMXEMOQCFQDTWOEAUYZSPNSERSFVFJJWTVOLIHBKMBCQIMJCXVEXFXXJFOGNQRVZJJZRFVPCUEZGKMBLYVKNPBYNFDNHXSDHATECQSTBJGZQMJWYPILKMFZZPACIFCQXQWNQTVCIANSVZDXUXAEHIYMKARGMLBPPWYXSCFZKTCHMOHCITRKYTTGIRJHKECAPKUDVXHHSEZOJAUCRDTVBMDXURPVMYDHRJZZZIVBFHJAUZFMXDUQSJQTNPUPZKHTSHNRGSOMWWXPBHBSTUSWSKPPNTBNEBQXEYUMGZCNZONVSFOIZZBIRRRVXEOLVKRYSLIXMSNHHMFFRUMGJVAEFIZHXLQEDGQNQCYNIYXAEDFLKNKSFIGIDMAOYGUQESWQJTLZIBWHIIEYPKJWANSJHEXSYESJNBKFZQIEVXSWMBMRSUMJVSCUMUIAXXSUNQOIQIDFUSNLELATPYNIOMBQVGESVLRGMWHPJAHCSDMNBUAVXQWRFGQAPGHAXYPLZRWVTOFSSKVHCDUSXETQWAANNBEFUVWFKNRBSYVRQSLWJWSCAFRUYONNBELSMRVECUKUPVRGSCPPTEJLSOWXDRAKFZCNBPXLSFGUTMBKHOCBOMNJYMMGLZTNQODOULGLLRQKSHPEDONIKNZXNWSWCISEBGIIHCTIYOGDEBIZFNSADRPXMROVBMOPTMMBKEYSZUCHAOVTSQSBWYNAMUSKHENZXRTJAFZPTJNIYOJHAWQCAGUKTIULDZSIVUPQQNTXJUZATEOKKXBONTKWQVLMVDYPTRCZXGJFWBZBDMIRCDTMFMNCQFPYCOHVXYPSOKRERZWOFWESJPSKOBHAANATKDYQMPAESMOVXDWFGRNFGTPUFHVJMLXKGRGRKBAFRFUPCUYYUSXBBIXNYRBCWPRLFNOLHGNTSFDPTOVPBQKSBPVBRDWQRWMYUAYMCQNQFRMMXNAIEIDSHZJPXIZNMXIIBSJBXTMDALVIISZEPEHAEBQOTYVJNXBDCBGNXFLRSZCDYMHMTVULSUHSBGLADBONVONFGLNEHJDVMEBQEYWASEDTVPPYWXLROUAWADWBUIFOWIWTUZXTZPQJELSFORSRSEXYBWRFOGNQLXWLAPTJSOVUWHJJNGNGHYWRARKIKDAGQZRDRONRPVQMFOSVKKAJYKMBGZCPDBHPFNZVBQGGGJQPRNTIQFDDFVELMVZGNCWQZWBLRIJRXKUZCZUMTSFETWTAAEQZGKTGSDDCZQAWOUTPDJXOPFYCNDLMDAZIYVTQDNCQBSKARSBCMMHKZCIPLURJCQVIJARDJOVEYCXLOFVDMATZXVEFGAUKRNCWMIHLSSKKDKSUKLZDQOTPHSULBQIFQGPFUAQWBOAKLQSLZNXYGQTHJRYIGEJPNOMAFCLRQQDTGJHUNRPBPJWECIJJMCWODVOYLKXQDUYBIQCVYTYRFHVSBEEJUKLGORNCVKSAMTFDVCCARHCSZQZXWJRMRUFPEJERMWFJPUULAAHXLILRIIQUFKYGKTSKRFBORGECWLNYNAQKCLPGEVEMTBKNZQUERTILTYRPJZXMDWERUIITLUVNJYBBGIWGHVJBVAANGZKHLDBTYMTJJSEEPZPKSPWAHAIPFCNMEXTWYZOLIWIGLOVBKJTMKRINMZEIPCGUVTXFVEWEYNZEFPVXOXIIYJPVTWJABYXJMQBFYBUQDSPLTUCMSJKENWUBCRYXFDVNJYSXSDVKSEWQZHKLDCPILSHLLMHBWOUBRQZDLHQZQVRSXGBDKLHIENUQJITXZRFZQHWNSQEOLFUKRYNZDSPFVGUYHHEXJRCJOWFUFSHQVWHJVZYGNJRQHUBULVFCIDHIRLDWSGKOVSNFDSCCRULMHXLGGXGAAXZFGPFLZNPCALEHIOZAQPCXVYGSKRZJTGKRICYRHFNVVXZXMONKMZLWIYYHNEPRMQHEFQLEMQKVCBEVEWJHZZDYZJGXCUAWXIIFYHJDUUDSWLYQCAAALSBXGLEZPRJNFHBTUTFCLZHCL",
    };

    {
        const table_columns = [_]muscle.Column{
            muscle.Column{
                .name = "pk",
                .data_type = muscle.DataType{ .TEXT = 2023 }, // Longer keys
            },
            .{
                .name = "int",
                .data_type = muscle.DataType{ .INT = {} },
            },
            .{
                .name = "real",
                .data_type = muscle.DataType{ .REAL = {} },
            },
        };
        const create_table_query: Query = Query{ .CreateTable = .{
            .table_name = table_name,
            .columns = &table_columns,
            .primary_key_column_index = 0,
        } };
        _ = try engine.execute_query(create_table_query);
    }

    const rand = std.crypto.random;
    for (insert_keys) |str| {
        const insert_query = Query{ .Insert = .{ .table_name = table_name, .values = &.{
            .{
                .column_name = "pk",
                .value = .{ .TEXT = str },
            },
            .{
                .column_name = "int",
                .value = .{ .INT = rand.int(i64) },
            },
            .{
                .column_name = "real",
                .value = .{ .REAL = rand.float(f64) },
            },
        } } };

        //std.debug.print("Inserting key: {s}\n", .{str});
        _ = try engine.execute_query(insert_query);
        //std.debug.print("insert_result: {any}\n", .{insert_result});

        var metadata = try engine.execute_query(select_metadata_query);
        //metadata.data.SelectTableMetadata.print();
        try validate_btree(&metadata.data.SelectTableMetadata);
        metadata.data.SelectTableMetadata.deinit();

        //const select_query = Query{ .Select = .{ .table_name = table_name } };
        //_ = try engine.execute_query(select_query);
    }

    std.debug.print("Test success\n", .{});
}

test "stress test randomized inserts on 1000 entries" {
    var file = try helpers.get_temp_file_path("test_stress_random_operations");
    defer file.deinit();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var engine = try execution.ExecutionEngine.init(allocator, file.file_path);

    defer {
        engine.deinit();
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) std.testing.expect(false) catch @panic("Memory leak while deiniting");
    }

    const table_name = "stress_test";

    // Create table with larger text capacity
    {
        const table_columns = [_]muscle.Column{
            muscle.Column{
                .name = "pk",
                .data_type = muscle.DataType{ .TEXT = 2023 }, // Longer keys
            },
            .{
                .name = "int",
                .data_type = muscle.DataType{ .INT = {} },
            },
            .{
                .name = "real",
                .data_type = muscle.DataType{ .REAL = {} },
            },
        };
        const create_table_query: Query = Query{ .CreateTable = .{
            .table_name = table_name,
            .columns = &table_columns,
            .primary_key_column_index = 0,
        } };
        _ = try engine.execute_query(create_table_query);
    }

    const get_insert_query = struct {
        fn f(pk: []const u8) Query {
            const rand = std.crypto.random;
            return Query{ .Insert = .{ .table_name = table_name, .values = &.{
                .{
                    .column_name = "pk",
                    .value = .{ .TEXT = pk },
                },
                .{
                    .column_name = "int",
                    .value = .{ .INT = rand.int(i64) },
                },
                .{
                    .column_name = "real",
                    .value = .{ .REAL = rand.float(f64) },
                },
            } } };
        }
    }.f;

    const rand = std.crypto.random;
    const select_metadata_query = Query{ .SelectTableMetadata = .{ .table_name = table_name } };

    var inserted_keys = std.ArrayList([2023]u8).init(allocator);
    defer inserted_keys.deinit();

    var successful_inserts: usize = 0;
    var total_attempts: usize = 0;

    while (successful_inserts < 1000) {
        var key: [2023]u8 = undefined;
        for (&key) |*char| {
            char.* = 'A' + rand.uintLessThan(u8, 26);
        }

        total_attempts += 1;

        // Check if key exists
        var exists = false;
        for (inserted_keys.items) |existing_key| {
            if (std.mem.eql(u8, &existing_key, &key)) {
                exists = true;
                break;
            }
        }

        const insert_response = try engine.execute_query(get_insert_query(&key));

        if (exists) {
            assert(insert_response.is_error_result());
            assert(insert_response.data.Error.error_code == error.DuplicateKey);
            // Don't count this towards successful inserts
        } else {
            // This should be a successful insert
            assert(!insert_response.is_error_result());
            try inserted_keys.append(key);
            successful_inserts += 1;

            // Validate every 100 successful insertions
            if (successful_inserts % 100 == 0) {
                var metadata = try engine.execute_query(select_metadata_query);
                try validate_btree(&metadata.data.SelectTableMetadata);
                std.debug.print("Validated at {} successful inserts (attempt {}): Height {}, Leaf cells {}\n", .{
                    successful_inserts,
                    total_attempts,
                    metadata.data.SelectTableMetadata.btree_height,
                    metadata.data.SelectTableMetadata.btree_leaf_cells,
                });
                metadata.data.SelectTableMetadata.deinit();
            }
        }
    }

    // Final validation
    var final_metadata = try engine.execute_query(select_metadata_query);
    try validate_btree(&final_metadata.data.SelectTableMetadata);

    std.debug.print("Test completed successfully!\n", .{});
    std.debug.print("  Successful inserts: {}\n", .{successful_inserts});
    std.debug.print("  Total attempts: {}\n", .{total_attempts});
    std.debug.print("  Duplicate attempts: {}\n", .{total_attempts - successful_inserts});
    std.debug.print("  Final tree height: {}\n", .{final_metadata.data.SelectTableMetadata.btree_height});
    std.debug.print("  Final leaf cells: {}\n", .{final_metadata.data.SelectTableMetadata.btree_leaf_cells});

    final_metadata.data.SelectTableMetadata.deinit();

    std.debug.print("Test success\n", .{});
}

test "stress test randomized operations on larger dataset" {
    var file = try helpers.get_temp_file_path("test_stress_random_operations_large");
    defer file.deinit();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    var engine = try execution.ExecutionEngine.init(allocator, file.file_path);

    defer {
        engine.deinit();
        const deinit_status = gpa.deinit();
        if (deinit_status == .leak) std.testing.expect(false) catch @panic("Memory leak while deiniting");
    }

    const table_name = "large_stress_test";

    // Create table with larger text capacity
    {
        const table_columns = [_]muscle.Column{
            muscle.Column{
                .name = "pk",
                .data_type = muscle.DataType{ .TEXT = 2023 }, // Longer keys
            },
            .{
                .name = "int_val",
                .data_type = muscle.DataType{ .INT = {} },
            },
            .{
                .name = "real_val",
                .data_type = muscle.DataType{ .REAL = {} },
            },
            .{
                .name = "text_val",
                .data_type = muscle.DataType{ .TEXT = 500 },
            },
        };
        const create_table_query: Query = Query{ .CreateTable = .{
            .table_name = table_name,
            .columns = &table_columns,
            .primary_key_column_index = 0,
        } };
        _ = try engine.execute_query(create_table_query);
    }

    const get_insert_query = struct {
        fn f(pk: []const u8, int_val: i64, real_val: f64, text_val: []const u8) Query {
            return Query{ .Insert = .{ .table_name = table_name, .values = &.{
                .{
                    .column_name = "pk",
                    .value = .{ .TEXT = pk },
                },
                .{
                    .column_name = "int_val",
                    .value = .{ .INT = int_val },
                },
                .{
                    .column_name = "real_val",
                    .value = .{ .REAL = real_val },
                },
                .{
                    .column_name = "text_val",
                    .value = .{ .TEXT = text_val },
                },
            } } };
        }
    }.f;

    const rand = std.crypto.random;
    var delete_query: Query = Query{ .Delete = .{ .table_name = table_name, .key = undefined } };
    const select_metadata_query = Query{ .SelectTableMetadata = .{ .table_name = table_name } };

    var inserted_keys = std.ArrayList([2023]u8).init(allocator);
    defer inserted_keys.deinit();

    var text_buffer: [500]u8 = undefined;

    // Phase 1: Insert 2000 random entries
    std.debug.print("Phase 1: Inserting 2000 random entries...\n", .{});
    for (0..2000) |i| {
        var key: [2023]u8 = undefined;
        for (&key) |*char| {
            char.* = 'A' + rand.uintLessThan(u8, 26);
        }

        // Generate random text value
        const text_len = rand.uintLessThan(usize, 400) + 100; // 100-499 chars
        for (text_buffer[0..text_len]) |*char| {
            char.* = 'a' + rand.uintLessThan(u8, 26);
        }

        // Check if key exists
        var exists = false;
        for (inserted_keys.items) |existing_key| {
            if (std.mem.eql(u8, &existing_key, &key)) {
                exists = true;
                break;
            }
        }

        const insert_response = try engine.execute_query(get_insert_query(
            &key,
            rand.int(i64),
            rand.float(f64),
            text_buffer[0..text_len],
        ));

        if (exists) {
            assert(insert_response.is_error_result());
            assert(insert_response.data.Error.error_code == error.DuplicateKey);
        } else {
            try inserted_keys.append(key);

            // Validate every 100 insertions
            if (i % 100 == 0) {
                var metadata = try engine.execute_query(select_metadata_query);
                try validate_btree(&metadata.data.SelectTableMetadata);
                metadata.data.SelectTableMetadata.deinit();
                std.debug.print("Validated at step {}: {} keys inserted\n", .{ i, inserted_keys.items.len });
            }
        }
    }

    std.debug.print("Phase 1 complete: {} unique keys inserted\n", .{inserted_keys.items.len});

    // Phase 2: Random deletions (delete ~30% of entries)
    std.debug.print("Phase 2: Random deletions...\n", .{});
    const delete_count = inserted_keys.items.len / 3;
    var deleted_count: usize = 0;

    for (0..delete_count) |i| {
        if (inserted_keys.items.len == 0) break;

        const random_index = rand.uintLessThan(usize, inserted_keys.items.len);
        const key_to_delete = inserted_keys.swapRemove(random_index);

        delete_query.Delete.key = .{ .TEXT = &key_to_delete };
        const delete_response = try engine.execute_query(delete_query);
        assert(!delete_response.is_error_result());

        deleted_count += 1;

        // Validate every 50 deletions
        if (i % 50 == 0) {
            var metadata = try engine.execute_query(select_metadata_query);
            try validate_btree(&metadata.data.SelectTableMetadata);
            metadata.data.SelectTableMetadata.deinit();
            std.debug.print("Validated deletion step {}: {} keys remaining\n", .{ i, inserted_keys.items.len });
        }
    }

    std.debug.print("Phase 2 complete: {} keys deleted, {} keys remaining\n", .{ deleted_count, inserted_keys.items.len });

    // Phase 3: Mixed operations (insert/delete randomly)
    std.debug.print("Phase 3: Mixed operations...\n", .{});
    for (0..1000) |i| {
        const operation = rand.uintLessThan(u8, 3); // 0=insert, 1=delete, 2=insert

        if (operation == 1 and inserted_keys.items.len > 100) {
            // Delete operation
            const random_index = rand.uintLessThan(usize, inserted_keys.items.len);
            const key_to_delete = inserted_keys.swapRemove(random_index);

            delete_query.Delete.key = .{ .TEXT = &key_to_delete };
            const delete_response = try engine.execute_query(delete_query);
            assert(!delete_response.is_error_result());
        } else {
            // Insert operation
            var key: [2023]u8 = undefined;
            for (&key) |*char| {
                char.* = 'A' + rand.uintLessThan(u8, 26);
            }

            // Generate random text value
            const text_len = rand.uintLessThan(usize, 400) + 100;
            for (text_buffer[0..text_len]) |*char| {
                char.* = 'a' + rand.uintLessThan(u8, 26);
            }

            // Check if key exists
            var exists = false;
            for (inserted_keys.items) |existing_key| {
                if (std.mem.eql(u8, &existing_key, &key)) {
                    exists = true;
                    break;
                }
            }

            const insert_response = try engine.execute_query(get_insert_query(
                &key,
                rand.int(i64),
                rand.float(f64),
                text_buffer[0..text_len],
            ));

            if (exists) {
                assert(insert_response.is_error_result());
                assert(insert_response.data.Error.error_code == error.DuplicateKey);
            } else {
                try inserted_keys.append(key);
            }
        }

        // Validate every 100 operations
        if (i % 100 == 0) {
            var metadata = try engine.execute_query(select_metadata_query);
            try validate_btree(&metadata.data.SelectTableMetadata);
            metadata.data.SelectTableMetadata.deinit();
            std.debug.print("Validated mixed operation step {}: {} keys\n", .{ i, inserted_keys.items.len });
        }
    }

    std.debug.print("Phase 3 complete: {} keys remaining\n", .{inserted_keys.items.len});

    // Phase 4: Stress test with rapid insertions
    std.debug.print("Phase 4: Rapid insertions stress test...\n", .{});
    for (0..500) |i| {
        var key: [2023]u8 = undefined;
        // Use a more predictable pattern to ensure uniqueness
        const base_char = 'A' + @as(u8, @intCast(i % 26));
        for (&key, 0..) |*char, j| {
            char.* = base_char + @as(u8, @intCast((j + i) % 26));
        }

        const text_len = 200;
        for (text_buffer[0..text_len]) |*char| {
            char.* = 'z' - @as(u8, @intCast(i % 26));
        }

        const insert_response = try engine.execute_query(get_insert_query(
            &key,
            @as(i64, @intCast(i)),
            @as(f64, @floatFromInt(i)) * 3.14159,
            text_buffer[0..text_len],
        ));

        if (!insert_response.is_error_result()) {
            try inserted_keys.append(key);
        }

        // Validate every 50 insertions
        if (i % 50 == 0) {
            var metadata = try engine.execute_query(select_metadata_query);
            try validate_btree(&metadata.data.SelectTableMetadata);
            metadata.data.SelectTableMetadata.deinit();
        }
    }

    // Final comprehensive validation
    var final_metadata = try engine.execute_query(select_metadata_query);
    try validate_btree(&final_metadata.data.SelectTableMetadata);

    std.debug.print("Final tree statistics:\n", .{});
    std.debug.print("  Height: {}\n", .{final_metadata.data.SelectTableMetadata.btree_height});
    std.debug.print("  Leaf cells: {}\n", .{final_metadata.data.SelectTableMetadata.btree_leaf_cells});
    std.debug.print("  Internal cells: {}\n", .{final_metadata.data.SelectTableMetadata.btree_internal_cells});
    std.debug.print("  Leaf pages: {}\n", .{final_metadata.data.SelectTableMetadata.btree_leaf_pages});
    std.debug.print("  Internal pages: {}\n", .{final_metadata.data.SelectTableMetadata.btree_internal_pages});
    std.debug.print("  Total keys: {}\n", .{inserted_keys.items.len});

    final_metadata.data.SelectTableMetadata.deinit();

    std.debug.print("Large dataset stress test completed successfully!\n", .{});
}

fn validate_btree(metadata: *const SelectTableMetadataResult) !void {
    const t = std.time.milliTimestamp();

    var allocator = metadata.pages.allocator;
    const NodeData = struct {
        min_key: ?[]const u8,
        max_key: ?[]const u8,
        page: muscle.PageNumber,
    };

    const L = std.DoublyLinkedList(NodeData);
    var queue = L{};
    const primary_key_data_type = metadata.table_columns.items[0].data_type;

    // if root is empty then it should be a leaf node
    if (metadata.pages.getPtr(metadata.root_page)) |page| {
        if (page.content_size == 0) {
            assert(page.cells.items.len == 0);
            assert(page.right_child == 0);
            assert(metadata.pages.count() == 1);
        } else {
            var node = try allocator.create(L.Node);
            node.data = .{
                .min_key = null,
                .max_key = null,
                .page = page.page,
            };
            queue.append(node);
        }
    } else unreachable;

    while (queue.popFirst()) |node| {
        defer allocator.destroy(node);

        const data = node.data;
        const page_meta = metadata.pages.getPtr(data.page).?;
        const is_leaf = page_meta.right_child == 0;

        //std.debug.print(
        //    \\
        //    \\validating node: {} slots: {} right_child: {}
        //    \\
        //,
        //    .{ data.page, page_meta.cells.items.len, page_meta.right_child },
        //);
        //if (primary_key_data_type == .BIN or primary_key_data_type == .TEXT) {
        //    std.debug.print("data.min_key: {s}.   {}\ndata.max_key: {s}.   {}\n", .{
        //        if (data.min_key != null) data.min_key.?[8..] else "",
        //        if (data.min_key != null) data.min_key.?.len else 0,
        //        if (data.max_key != null) data.max_key.?[8..] else "",
        //        if (data.max_key != null) data.max_key.?.len else 0,
        //    });
        //}

        // every page should have atleast one cell
        assert(page_meta.cells.items.len > 0);

        // need to check that all childrens are unique
        var child_pages = std.ArrayList(muscle.PageNumber).init(allocator);
        defer child_pages.deinit();

        // append right child to child_pages
        if (!is_leaf) try child_pages.append(page_meta.right_child);

        for (page_meta.cells.items, 0..) |cell, slot| {
            const curr_key = cell.key;

            // check that all child pages and unique
            if (!is_leaf) {
                for (child_pages.items) |n| assert(n != cell.left_child);
                try child_pages.append(cell.left_child);
            }

            // assert that keys are in order
            if (slot > 0) {
                assert(serde.compare_serialized_bytes(
                    primary_key_data_type,
                    page_meta.cells.items[slot - 1].key,
                    curr_key,
                ) == std.math.Order.lt);
            }

            if (data.min_key) |min_key| {
                if (!(serde.compare_serialized_bytes(primary_key_data_type, min_key, curr_key) == std.math.Order.lt)) {
                    if (primary_key_data_type == .BIN or primary_key_data_type == .TEXT) {
                        std.debug.print("curr_key: {s} \nmin_key: {s}\n\n", .{ curr_key[8..12], min_key[8..12] });
                    } else {
                        std.debug.print("curr_key: {d} \nmin_key: {d}\n\n", .{ curr_key, min_key });
                    }

                    assert(false);
                }
            }

            if (data.max_key) |max_key| {
                if (!(serde.compare_serialized_bytes(primary_key_data_type, curr_key, max_key).compare(.lte))) {
                    if (primary_key_data_type == .BIN or primary_key_data_type == .TEXT) {
                        std.debug.print("curr_key: {s} \nmax_key: {s}\n\n", .{
                            curr_key[8..],
                            max_key[8..],
                        });
                    } else {
                        std.debug.print("curr_key: {d} \nmax_key: {d}\n\n", .{ curr_key, max_key });
                    }

                    assert(false);
                }
            }

            // For internal nodes validate cells left_child is non zero and push data inside the queue
            if (!is_leaf) {
                const pivot_cell = cell;
                const pivot_cell_slot = slot;

                // child is in the middle between pivot cell and cell before pivot cell.
                // for the left child all the keys must be less than or equal to pivot cell
                // And all the keys must be greater than one cell before pivot cell.

                assert(pivot_cell.left_child != 0);

                const next_min_key =
                    if (pivot_cell_slot > 0)
                        page_meta.cells.items[pivot_cell_slot - 1].key
                    else
                        data.min_key;

                const next_max_key = pivot_cell.key;

                // append child to queue
                const child_node = try allocator.create(L.Node);
                child_node.data = .{
                    .min_key = next_min_key,
                    .max_key = next_max_key,
                    .page = cell.left_child,
                };
                queue.append(child_node);
            } else {
                // for leaf nodes left_child should be zero
                assert(cell.left_child == 0);
            }

            // validate left and right pointers
            if (page_meta.left != 0) {
                const left = metadata.pages.getPtr(page_meta.left).?;
                assert(left.right == page_meta.page);
            }

            if (page_meta.right != 0) {
                const right = metadata.pages.getPtr(page_meta.right).?;
                assert(right.left == page_meta.page);
            }
        }

        // append right child to queue
        if (!is_leaf) {
            const min_key = page_meta.cells.items[page_meta.cells.items.len - 1].key;
            const max_key = data.max_key;

            const child_node = try allocator.create(L.Node);
            child_node.data = .{
                .min_key = min_key,
                .max_key = max_key,
                .page = page_meta.right_child,
            };
            queue.append(child_node);
        }
    }

    _ = t;
    //std.debug.print("{}ms VALID\n", .{std.time.milliTimestamp() - t});
}
